<!DOCTYPE html>
<html>
	<head>
		<title>Premier rendu 3D avec Three.js</title>
		<meta charset="utf-8">
	</head>
<body>
	<div id="container" style="width: 640px; height: 480px; background-color: #000000;"></div>
	<script src="./js/lib/three.min.js"></script>
	<script src="./js/lib/three.js"></script>
	<script src="./js/lib/OrbitControls.js"></script>
	<script src="./js/lib/dat.gui.min.js"></script>
	<script src="./js/lib/Raycaster.js"></script>
	<script type="text/javascript">
	//but : selectionner un objet => scale
	var renderer, scene, camera, mesh;
	var idObject;
	var gui, menuO, menuP;
	var tabGeometries = [
		{ type: 'BoxGeometry', geometry: new THREE.BoxGeometry( 200, 200, 200, 2, 2, 2 )},
		{ type: 'SphereGeometry', geometry: new THREE.SphereGeometry( 100, 12, 12 ) },
		{ type: 'PlaneGeometry', geometry: new THREE.PlaneGeometry( 100, 12, 12 ) },
		{ type: 'PointGeometry', geometry: new THREE.Geometry() }
		];
	var options;
	var sac3DObject; // contient tous les objects 3d de la scene
	var raycaster = new THREE.Raycaster();
	var mouse = new THREE.Vector2();
	var SELECTED;

	init();
	animate();

	function init(){
		//rendere
		renderer=new THREE.WebGLRenderer();//moteur de rendu
		renderer.setSize(window.innerWidth, window.innerHeight);
		document.getElementById('container').appendChild(renderer.domElement);
		//scene
		scene= new THREE.Scene();//scene
		scene.background=new THREE.Color(0x70E5DA);
		//camera
		camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight,1,10000);
		camera.position.set(0,0,1000);
		scene.add(camera);

		//creation du sac
		sac3DObject= new THREE.Group();
		scene.add(sac3DObject);

		//Creation d'un objet à ajouter dans le sac
		/*var geometry = new THREE.CubeGeometry(200,200,200);
		var material = new THREE.MeshBasicMaterial({color : 0xff0000, wireframe: false});
		mesh=new THREE.Mesh(geometry, material);
		mesh.name="0";
		sac3DObject.add(mesh);
		var geometry = new THREE.CubeGeometry(100,100,200);
		var material = new THREE.MeshBasicMaterial({color : 0xff0000, wireframe: false});
		var mesh2=new THREE.Mesh(geometry, material);
		mesh2.name="1";
		sac3DObject.add(mesh2);*/



		////////////////
		//menu de base//
		////////////////
		var tabGeometries = {
			BoxGeometry: 0,
			SphereGeometry: 1,
			PlaneGeometry:2,
			PointGeometry:2
		};
		options={ 
					geometry: 0,
					scale: 0.1,
					x: 0, y: 0, z:0,
					color: "#ff0000",
					reset : function(){}
				};
		gui = new dat.GUI({width: 350});
		menuO=gui.addFolder('Ajout Object');
		menuO.add( options, 'geometry', tabGeometries ).onChange( function( value ) {
					AjoutObjectGeometry();
			} );
		menuP=gui.addFolder('Element');
		console.log(menuP);
		console.log(menuO);
		//dat.GUI.toggleHide();
		
		
		//action de la souris
		/*window.addEventListener( 'mousemove', onMouseMove, false );*/
		window.addEventListener( 'mousedown', onMouseDown, false );
		//premier rendu
		renderer.render(scene, camera);
		//console.log(mesh.id);
		//console.log(mesh2.id);
		//console.log(sac3DObject.getObjectById(mesh2.id, true));

	}


	function render(){
		
		renderer.render(scene, camera);

	}


	function animate(){
		requestAnimationFrame(animate);//fonction recuresive a chaque frame
		if ( mesh == undefined ) {//si aucun mesh alors on fait rien
			render();
		}else{
			var i=0;
			var nbChildren = sac3DObject.children.length;
			for(i=0;i<nbChildren;i++){
				sac3DObject.children[i].rotation.x += 0.01; //tourne le dernier mesh crée
				sac3DObject.children[i].rotation.y += 0.02;
			}
			render();
		}
	}

	function setScale(id,val){
		var object = sac3DObject.getObjectById(id);
		object.scale.set( val, val, val );
	}

	function setPosition(id,valx,valy,valz){
		var object = sac3DObject.getObjectById(id);
		object.position.set( valx, valy,valz );
	}

	function setColor(id,val){
		var object = sac3DObject.getObjectById(id);
		object.material.color.setHex( val.replace("#","0x") );
	}

	function SelectionnerObjet(pListeIntersect){
		if( pListeIntersect.length>0){
			var intersect = pListeIntersect[ 0 ];
			/*console.log(intersect);
			console.log(intersect.object.position.x);
			console.log(intersect.object.position.y);
			console.log(intersect.object.position.z);
			console.log(intersect.object.scale);*/

			if( SELECTED != intersect){
				if((intersect.object.position.x !== 0) || (intersect.object.position.y !== 0) || (intersect.object.position.z !== 0) || (intersect.object.scale.x !== 1)){
					retablirMenu(intersect.object.scale.x,intersect.object.position.x,intersect.object.position.y,intersect.object.position.z,intersect.object.material.color);
				}else{
					resetMenu();
				}
				if(SELECTED) SELECTED.object.material.color.set(0xff0000);
				SELECTED = intersect;
				idObject = intersect.object.id;
				SELECTED.object.material.color.set(0xffff00);
			}
				console.log(intersect);
				console.log(intersect.object.id);
				menuGeometry(idObject);
		}else{
			if ( SELECTED ) SELECTED.object.material.color.set( 0xff0000 )
				SELECTED = null;
				//detruireMenu();	
		}
			
	}


	function menuGeometry(){
		console.log(gui);
		console.log(menuP);
		console.log(options);
		if(menuP.__controllers.length==0){
			menuP.add( options, 'scale', 0,1 ).listen().onChange( function( value ) { setScale(idObject,options.scale); } );
			menuP.add( options, 'x').min(0).max(200).listen().onChange( function( value ) { setPosition(idObject,options.x,options.y,options.z); } );
			menuP.add( options, 'y').min(0).max(200).listen().onChange( function( value ) { setPosition(idObject,options.x,options.y,options.z); } );
			menuP.add( options, 'z').min(0).max(200).listen().onChange( function( value ) { setPosition(idObject,options.x,options.y,options.z); } );
			menuP.addColor( options, 'color').name('color').listen().onChange( function( value ) { setColor(idObject,options.color); } );
			menuP.add(options,'reset').name("Reset Element").listen().onChange( function( value ) { resetElement(idObject); } );
			menuP.open();
		}
		console.log(gui);
		console.log(menuP.__controllers.length);

	}

	/*function detruireMenu(){
		gui.remove(menuP);
	}*/

	function resetMenu(){
		options.scale = 1;
		options.x = 0;
		options.y = 0;
		options.z = 0;
		options.color = "#ff0000";
	}

	function retablirMenu(valSc,valx,valy,valz,col){
		options.scale = valSc;
		options.x = valx;
		options.y = valy;
		options.z = valz;
		//options.color = col.replace("0x","#");
	}


	function resetElement(id){
		options.scale = 1;
		options.x = 0;
		options.y = 30;
		options.z = 0;
		options.color = "#ff0000";
		setScale(id,options.scale)
		setPosition(id,options.x,options.y,options.z)
		setColor(id,options.color);
		console.log(options);
	}

	function AjoutObjectGeometry(){
		geometry = tabGeometries[options.geometry].geometry;
		if(tabGeometries[options.geometry]=='PointGeometry'){
			geometry.vertices.push(new THREE.Vector3(0,0,0));
			var material = new THREE.PointsMaterial( { size: 1, sizeAttenuation: false } );
			mesh = new THREE.Points( geometry, material);		
			sac3DObject.add(mesh);
		}else{
			var material = new THREE.MeshBasicMaterial({color : 0xffff00, wireframe: true});
			mesh=new THREE.Mesh(geometry, material);
			sac3DObject.add(mesh);
		}
			console.log(mesh.id);
	} 

	function onMouseDown( event ){
		mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
		mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
		raycaster.setFromCamera(mouse, camera)//position du raycaster avec la camera et la position de la souris
		var intersects = raycaster.intersectObjects( sac3DObject.children );
		SelectionnerObjet(intersects);
	}

	</script>
</body>
</html>